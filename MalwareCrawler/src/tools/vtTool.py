#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  ██╗   ██╗████████╗████████╗ ██████╗  ██████╗ ██╗     
#  ██║   ██║╚══██╔══╝╚══██╔══╝██╔═══██╗██╔═══██╗██║     
#  ██║   ██║   ██║█████╗██║   ██║   ██║██║   ██║██║     
#  ╚██╗ ██╔╝   ██║╚════╝██║   ██║   ██║██║   ██║██║     
#   ╚████╔╝    ██║      ██║   ╚██████╔╝╚██████╔╝███████╗
#    ╚═══╝     ╚═╝      ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝
#
# Find the name of the evil
#
# http://code.google.com/p/malware-crawler/
#
# Robby Zeitfuchs - robby@zeitfuchs.org - 2013-2015
# Mark Lawrenz - Mark.Lawrenz@web.de
#
# any subjection, tips, improvement are welcome
#
# Licence: GNU GPL v.3.0
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.                                                     

import re
import sys
import urllib2
import argparse

try:
    from BeautifulSoup import BeautifulSoup as bs
except ImportError:
    raise ImportError, 'Beautiful Soup parser is required to run this program: http://www.crummy.com/software/BeautifulSoup/'

DEBUG = False
CLUSTER = True

try:
    import numpy as np
    from fuzzywuzzy import fuzz
    from sklearn.cluster import DBSCAN
except ImportError:
    CLUSTER = False

VIRUSTOTAL_FILE_URL = 'https://www.virustotal.com/de/search/?query=%s'

TRENNER = [".", ":", "-", "~", "@", "!", "/", "_", ";", "[", "]", "(", ")"]

MAPPING = {" loader":"downloader",
           " risk":"riskware",
           "adware":"riskware",
           "backdoor":"trojan",
           "banker":"trojan",
           "bkdr":"trojan",
           "bundler":"riskware",
           "crypt":"ransomware",
           "cryptor":"ransomware",
           "dldr":"downloader",
           "down ":"downloader",
           "downware":"downloader",
           "grayware":"riskware",
           "hack ":"riskware",
           "hackkms":"riskware",
           "hacktool":"riskware",
           "hktl":"riskware",
           "injector":"trojan",
           "keygen":"riskware",
           "kms":"riskware",
           "krypt":"ransomware",
           "kryptik":"ransomware",
           "load ":"downloader",
           "lock":"ransomware",
           "muldown":"downloader",
           "onlinegames":"riskware",
           "ransom ":"ransomware",
           "rkit":"rootkit",
           "rogue":"riskware",
           "rogueware":"riskware",
           "rtk":"rootkit",
           "scareware":"riskware",
           "startpage":"riskware",
           "suspicious":"riskware",
           "sys":"rootkit",
           "trj":"trojan",
           "troj":"trojan",
           "unwanted":"riskware"}

REPLACE = [" tool",
           "agent",
           "application",
           "backdoor",
           "based",
           "behaves",
           "downloader",
           "dropped",
           "dropper",
           "executor",
           "exploit",
           "gen",
           "generic",
           "genome",
           "heur",
           "heuristic",
           "like",
           "malware",
           "obfuscated",
           "optional",
           "packed",
           "posible",
           "possible",
           "program",
           "ransomware",
           "reputation",
           "riskware",
           "rootkit",
           "suspect",
           "trojan",
           "unclassified",
           "unknown",
           "variant",
           "virus",
           "ware",
           "win32 ",
           "win64",
           "worm"]

def install():
    print "\n"
    print "Lexical clustering requires the following dependencies:"
    print 'numpy: http://scikit-learn.org/stable/install.html'
    print 'scikit-learn: http://scikit-learn.org/stable/install.html'
    print 'FuzzyWuzzy: https://github.com/seatgeek/fuzzywuzzy'
    print 'python-levenshtein: https://github.com/miohtama/python-Levenshtein'
    print "\n"
    print "Install on Ubuntu:"
    print " sudo apt-get install python-numpy python-scipy python-levenshtein"
    print " pip install -U scikit-learn"
    print "\n"

def logo():
    print "\n"
    print "  ██╗   ██╗████████╗████████╗ ██████╗  ██████╗ ██╗"
    print "  ██║   ██║╚══██╔══╝╚══██╔══╝██╔═══██╗██╔═══██╗██║"
    print "  ██║   ██║   ██║█████╗██║   ██║   ██║██║   ██║██║"
    print "  ╚██╗ ██╔╝   ██║╚════╝██║   ██║   ██║██║   ██║██║"
    print "   ╚████╔╝    ██║      ██║   ╚██████╔╝╚██████╔╝███████╗"
    print "    ╚═══╝     ╚═╝      ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝"
    print " Find the name of the evil\n"
    print " Robby Zeitfuchs"
    print " Mark Lawrenz"
    print " Copyright (c) 2013-2015"

# beautifulsoup parser
def parse(url):
    request = urllib2.Request(url)
    request.add_header('User-Agent', 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1)')
    try:
        http = bs(urllib2.urlopen(request, timeout=30))
    except Exception, e:
        print("%s - Error parsing %s" % (e, url))
        return
    return http  

def fileFound(soup):
    s = soup.find("h2", { "class" : "alert-heading" })

    if s:
        s = str(s)
        i = s.find("Datei nicht gefunden")
        if i > 0:
            return False
    return True 

def processSHA256(sha256):
    # parser
    soup = parse(VIRUSTOTAL_FILE_URL % sha256)

    if fileFound(soup):
        dateinamen = []
        # Extract Filenames
        try:
            s = soup.find(text="Dateinamen")
            s = s.parent.parent.parent
            s = s.prettify()
            s = s.replace('<br />', "").replace('\n', "|").replace(' ', "")
            s = s.split("|")
            
            for dateiname in s:
                if "<" not in dateiname and "Dateinamen" not in dateiname and dateiname != "":
                    dateinamen.append(dateiname)

        except Exception, e:
            print("%s - Error Determining filenames" % e)
            return 

        # Extract Malware-Names
        try:
            malwarenames = []
            s = soup.findAll("td", { "class" : "ltr text-red" })
            
            for malwarename in s:
                name = malwarename.contents[0]
                name = name.replace('<br />', "").replace('\n', "")
                if "<" not in malwarename and malwarename != "":
                    malwarenames.append(name.strip())
        except Exception, e:
            print("%s - Error Determining Malware-Names" % e)
            return   
        
        return {"malwarenames":malwarenames, "filenames":dateinamen}
    return None

def wordFrequencyReport(wordCount):
    mostFrequentWord = ''
    countWord = 0
    secWord = ''
    secCountWord = 0
    for wort, count in sorted(wordCount.iteritems(), key=lambda (k, v):(v, k)):
        if DEBUG:
            print "'%s':%s," % (wort, count)
        if count > countWord:
            secWord = mostFrequentWord
            secCountWord = countWord
            mostFrequentWord = wort
            countWord = count
    
    print '--- scanner malware family determination ---'
    print "Most frequent word: %s (count=%d)" % (mostFrequentWord, countWord)
    if secCountWord > 0:
        print "Second most frequent word: %s (count=%d)" % (secWord, secCountWord)
    print "\n"

def simpleWordFrequency(tmpNames):
    # find the most frequently occuring words
    wordCount = {}
    for wort in tmpNames:
        w = wort.strip()
        if len(w) > 0:
            wordCount[w] = wordCount.get(w, 0) + 1
    
    return wordCount

def normalizeMalwareNamesStep2(names):
    # sort Replace Map
    REPLACE.sort(key=lambda item:(-len(item), item))
    # delete not usable words
    for r in REPLACE:
        names = names.replace(r, " ")
    
    # delete special characters
    names = "".join(re.findall("[a-z\s]*", names))
    # delete multiple whitespaces
    names = re.sub('\s{2,}', ' ', names)
    # delete small words
    tmpNames = []
    for name in names.strip().split(' '):
        if len(name.strip()) > 3:
            tmpNames.append(name.strip())
    
    return tmpNames

def normalizeMalwareNamesStep1(malwarenames):
    # malwarenames-list to string
    names = " ".join(malwarenames)
    for trn in TRENNER:
        names = names.replace(trn, " ").lower()
    
    for key in sorted(MAPPING, key=len, reverse=True):
        names = names.replace(key, MAPPING[key])
    
    return names

# similarity from the ratio, token_sort and token_set ratio methods in FuzzyWuzzy
def computeSimilarity(s1, s2):
    return 1.0 - (0.01 * max(
        fuzz.ratio(s1, s2),
        fuzz.token_sort_ratio(s1, s2),
        fuzz.token_set_ratio(s1, s2)))
    
def uniqueList(l):
    ulist = []
    [ulist.append(x) for x in l if x not in ulist]
    return ulist

def clusterMalwareNames(malwareNames):
    # strictly lexical clustering over malware-names
    wordCount = {}
    # create a distance matrix
    matrix = np.zeros((len(malwareNames), len(malwareNames)))
    for i in range(len(malwareNames)):
        for j in range(len(malwareNames)):
            if matrix[i, j] == 0.0:        
                matrix[i, j] = computeSimilarity(malwareNames[i], malwareNames[j])
                matrix[j, i] = matrix[i, j]
    
    # Scikit-Learn's DBSCAN implementation to cluster the malware-names
    clust = DBSCAN(eps=0.1, min_samples=5, metric="precomputed")
    clust.fit(matrix)    
    
    preds = clust.labels_
    clabels = np.unique(preds)
    
    # create Word-Count Map
    for i in range(clabels.shape[0]):
        if clabels[i] < 0:
            continue
        
        cmem_ids = np.where(preds == clabels[i])[0]
        cmembers = []
        
        for cmem_id in cmem_ids:
            cmembers.append(malwareNames[cmem_id])
        
        wordCount[", ".join(uniqueList(cmembers))] = len(cmem_ids)
    return wordCount

def main(sha256):
    sha256 = sha256.split(",")
    dateinamen = []
    malwarenames = []
    
    for hash in sha256:
        hash = hash.strip()
        if (len(hash) != 64):
            print "This is not a sha256!: " + hash
            continue
        
        values = processSHA256(hash)
        if values:
            dateinamen += values.get("filenames")
            malwarenames += values.get("malwarenames")
           
    # Delete duplicates
    dateinamen = uniqueList(dateinamen)
           
    # sort dateinamen Map
    dateinamen.sort(key=lambda item: (-len(item), item))
           
    # File-Names Report
    print "\n"
    print '--- malware file names ---'
    for name in dateinamen:   
        print name
    print "\n"
    
    # Normalize Step 1
    names = normalizeMalwareNamesStep1(malwarenames)
    
    print '--- scanner malware classification ---'
    print 'ransomware: ' + str(names.count("ransomware"))
    print '   dropper: ' + str(names.count("dropper"))
    print '   exploit: ' + str(names.count("exploit"))
    print 'downloader: ' + str(names.count("downloader"))
    print '  riskware: ' + str(names.count("riskware"))
    print '   rootkit: ' + str(names.count("rootkit"))
    print '      worm: ' + str(names.count("worm"))
    print '    trojan: ' + str(names.count("trojan"))
    print "\n"
    
    # Normalize Step 2
    names = normalizeMalwareNamesStep2(names)
    
    if DEBUG:
        print " ".join(names)
    
    # create Word-Count-Map
    if CLUSTER:
        # strictly lexical clustering over malware-names
        wordCountMap = clusterMalwareNames(names)
    else:
        wordCountMap = simpleWordFrequency(names)
    
    # Print the Result
    wordFrequencyReport(wordCountMap)
    
if __name__ == '__main__':         
    parser = argparse.ArgumentParser(description='VirusTotal MalwareName-Tool')
    parser.add_argument("-hash", "--hashlist", help="Malware hash or CSV Hashlist", required=True)
    parser.add_argument("--debug", help="Debugmodus", action="store_true", default=False)
    parser.add_argument("--cluster", help="Strictly lexical clustering over malware-names", action="store_true", default=False)
    args = parser.parse_args()
    
    DEBUG = args.debug
    
    # Print Logo 
    logo()
    
    if not args.cluster:
        CLUSTER = False
    elif args.cluster and not CLUSTER:
        install()
        sys.exit()
    
    main(args.hashlist)